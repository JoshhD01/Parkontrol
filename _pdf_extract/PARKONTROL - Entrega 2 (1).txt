PARKONTROL   
Entrega  2  
Equipo  de  Trabajo   
Responsables   Emanuel  Gallego  Cano   Josu√©  Gomez  Granda   Dariana  Lopera   
UNIVERSIDAD  DE  MEDELL√çN  
2025
 PROYECTO  PARKONTROL.   

Lo  que  se  requiri√≥  hacer:   
1)  Tener  su  modelo  poblado  con  al  menos  100  Empresas  que  adquieren  el  Software  Parkcontrol  como  servicio,  cada  uno  tiene  al  menos  6  usuarios  en  sistema  de  los  cuales  solo  1  es  administrador.  De  las  100  empresas  anteriores  al  menos  50,  tienen  3  parqueaderos  en  diferentes  puntos  de  la  ciudad,  es  de  anotar  que  deben  definirle  las  tarifas  a  cada  una  de  las  empresas  y  en  el  registro  de  veh√≠culos  y  reservas  y  pagos  vamos  a  simular  que  por  cada  parqueadero  que  tienen  las  empresas  han  pasado  al  menos  150  Autom√≥viles,  a  los  cuales  se  les  a  realizado  el  debido  proceso  de  facturaci√≥n  y  pago.  
2)   Crear  todos  los  √≠ndices  necesario  para  la  soluci√≥n  de  acuerdo  a  los  conceptos  vistos  en  clase;  cada  indice  deber√°  documentarse  como  parte  del  primer  entregable.  
3)  Crear  4  Vistas  que  ustedes  visionen  que  debe  tener  su  sistema.  Nota:  Una  de  las  vistas  deber√°  tener  3  join  con  diferentes  tablas  de  su  sistema.  
4)  Crear  un  paquete  que  tenga  por  nombre  PKG_CENTRAL,  y  dentro  de  el  cree  un  procedimiento  que  permita  realizar  el  control  y  pago  de  del  parqueo,  Cree  un  segundo  procedimiento  que  permita  validar  o  encontrar  por  placa  el  automovil  de  una  persona  y  que  le  indique  en  cual  celda  se  encuentra.  
5)  Particionar  la  tabla  Pagos,  por  el  m√©todo  que  ustedes  crean  es  mas  eficiente  de  acuerdo  a  lo  que  se  va  a  ver  en  el  curso.  
Lo  que  se  hizo:  
1.  Introducci√≥n  
El  presente  documento  describe  la  implementaci√≥n  t√©cnica  avanzada  realizada  sobre  la  base  de  datos  del  proyecto  Parkontrol ,  con  el  fin  de  cumplir  los  requerimientos  de:  
‚óè  Particionamiento  de  tablas   ‚óè  Optimizaci√≥n  por  √≠ndices  y  tablespaces   ‚óè  Poblamiento  masivo   ‚óè  Creaci√≥n  de  vistas  anal√≠ticas   ‚óè  Estad√≠sticas  y  performance  tuning  

 ‚óè  Procedimientos  almacenados  funcionales  para  el  sistema  SaaS   
El  objetivo  fue  garantizar  escalabilidad,  alto  rendimiento,  mantenibilidad  y  consistencia  transaccional ,  acorde  al  contexto  de  un  sistema  real  de  parqueadero.  
 
 2.  Configuraci√≥n  de  Tablespaces  
Se  cre√≥  infraestructura  f√≠sica  para  separar:  
Tablespace  Prop√≥sito  
TS_PARKONTROL_DATA Almacenamiento  de  datos  
TS_PARKONTROL_INDEX Almacenamiento  de  √≠ndices  
TS_PAGO_Q1/Q2/Q3/Q4 Particiones  trimestrales  para  la  tabla  PAGO  Justificaci√≥n:  Mejora  en  rendimiento,  recuperaci√≥n,  administraci√≥n  y  balanceo  de  carga  I/O.  
 
3.  Particionamiento  de  la  tabla  PAGO  
Se  particion√≥  la  tabla  PAGO  por  rango  por  fecha  de  pago ,  en  trimestres,  para  escalabilidad  hist√≥rica:  
‚óè  PAGO_Q1  =  Enero  ‚Äì  Marzo   ‚óè  PAGO_Q2  =  Abril  ‚Äì  Junio   ‚óè  PAGO_Q3  =  Julio  ‚Äì  Septiembre   ‚óè  PAGO_Q4  =  Octubre  ‚Äì  Diciembre   
 Esta  estrategia  reduce  tiempos  de  consulta  y  mantenimiento  

 Los  √≠ndices  fueron  reconstruidos. 
 
4.  Reconstrucci√≥n  y  alineaci√≥n  de  Constraints  e  √çndices  
Despu√©s  de  particionar,  se:  
‚úî  Renombraron  FK  ligadas  a  PAGO   ‚úî  Se  recrearon  √≠ndices  locales   ‚úî  Se  movieron  √≠ndices  a  TS_PARKONTROL_INDEX   ‚úî  Se  activ√≥  monitoring  usage   ‚úî  Se  verific√≥  uso  real  (V$OBJECT_USAGE)  
Esto  garantiza  que  el  optimizador  use  los  √≠ndices  correctos  para  las  particiones.  
 
 5.  Poblamiento  Masivo  (30.000+  registros)  
Se  desarroll√≥  un  script  PL/SQL  para  insertar  datos  simulados:  
‚óè  200  parqueaderos   ‚óè  200  celdas  c/u   ‚óè  Reservas  por  2  a√±os  hist√≥ricos   ‚óè  Pagos  asociados   ‚óè  Clientes  factura   ‚óè  Facturas  electr√≥nicas   
Resultados:  
Registros  aprox.  +30.000  

  
  
  
Commit  por  batch  Manejo  de  excepciones  Simulaci√≥n  realista  de  flujo  de  parqueadero  
 
 6.  Procedimientos  Almacenados  (Paquete  PKG_CENTRAL)  
Se  cre√≥  paquete  funcional  para  integrarse  con  Backend  NodeJS  +  Angular:  
Procedimiento  Funci√≥n  
PROC_CONTROL_PAGO Procesa  el  pago  de  una  reserva  abierta  

PROC_BUSCAR_PLACA Localiza  veh√≠culo  en  tiempo  real  Validaciones  realizadas  
Solo  permite  pago  si  reserva  est√°  ABIERTA  No  permite  pagos  duplicados  por  misma  reserva  Actualiza  inmediatamente  estado  y  salida  del  veh√≠culo  
Comportamiento  listo  para  consumo  desde  IU  en  Angular  
 
üìà  7.  Vistas  Operacionales  y  Anal√≠ticas  
Vista  Prop√≥sito  
VW_OCUPACION_PARQUEADERO Nivel  de  ocupaci√≥n  actual  
VW_HISTORIAL_RESERVAS Trazabilidad  completa  
VW_FACTURACION_COMPLETA Auditor√≠a  contable  
VW_INGRESOS_POR_PARQUEADERO_MENSUAL 
KPI  de  ingresos  mensuales  
 
Probadas  con  EXPLAIN  PLAN  (F10)   
 
8.  Estad√≠sticas  y  Optimizaci√≥n  

Acciones  realizadas:  
‚óè  DBMS_STATS.GATHER_TABLE_STATS en  tablas  clave   ‚óè  An√°lisis  de  cardinalidad  y  costos   ‚óè  Activaci√≥n  de  index  monitoring   ‚óè  Verificaci√≥n  de  uso  real  de  √≠ndices   ‚óè  Validaci√≥n  de  plan  de  ejecuci√≥n  (EXPLAIN  PLAN  con  F10)   
Oracle  confirm√≥  uso  de  HASH  JOIN  +  INDEX  JOIN  eficientes  
 
9.  Integridad,  consistencia  y  transaccionalidad  
Se  garantiz√≥  que:  
‚óè  No  se  permiten  pagos  duplicados   ‚óè  Pagos  dependen  de  reservas  v√°lidas   ‚óè  Consistencia  al  cerrar  reserva  vs.  liberar  celda   ‚óè  Uso  de  EXCEPTION  WHEN y  mensajes  controlados   ‚óè  ACID  mediante  COMMIT controlado   
 
10.  Justificaci√≥n  de  Arquitectura  y  Resiliencia  
Tema  Decisi√≥n  Raz√≥n  
Alta  disponibilidad  Active‚ÄìStandby  (Master‚ÄìStandby)  
Modelo  √≥ptimo  para  OLTP  +  integridad  de  pagos  

√çndices  particionados  No  particionados  
Mejor  rendimiento  ya  que  cardinalidad  por  partici√≥n  no  lo  requer√≠a  
Particionamiento  PAGO  Trimestral  Consultas  hist√≥ricas  +  auditor√≠a  fiscal  
Reglas  de  negocio  Validaci√≥n  de  pago  √∫nico  
coherencia  transaccional  
 Modelo  profesional  basado  en  buenas  pr√°cticas  empresariales
 
Estructura  del  directorio  
1.  Modulo  AdminGlobal  :   a.  depende  servicio  empresas:  crear  empresa,  listar  empresa,  obtener  empresa  por  id,   b.  depende  servicio  usuarios  :  crear  usuario  con  rol  ‚Äúadmin‚Äù  
 Metodo  Endpoint  descripcion  DTo  entrada  Dto  Salida  Rol  requerido  
POST  /empresas  Crea  una  nueva  empresa  en  el  sistema.  Puede  crearse  sin  administrador  asignado.  
createEmpresaDto  Body:  {  nit:  string,  nombre:  string,  direccion?:  string  } 
empresaCreatedResponseDto  200:  {  id,  nit,  nombre,fechaCreacion  } 
Super_admin  
GET  /empresas  Lista  todas  las  empresas  registradas  (con  o  sin  admin  asignado).  
 empresaResponseDto[]  200:  {  id,  nombre,  nit,  administrador?:  {  id,  nombre,  email  },  parqueaderos:  []  } 
super_admin  
GET  empresas/:id  Obtiene  los  detalles  de  una  empresa  espec√≠fica  (datos  generales,  si  tiene  administrador  asignado,  y  parqueaderos  asociados).   
Params:  id:  number 
EmpresaResponseDto  200:  {  id,  nombre,  nit,  administrador?:  {  id,  nombre,  email  },  parqueaderos:[]} 
super_admin,  admin:  ver  detalles  solo  de  empresa  propia  

PUT  /empresas/:id/cambiar-admin  
Cambia  el  administrador  principal  de  una  empresa  (por  ejemplo,  reasignar  otro  usuario  con  rol  ADMIN_EMPRESA).  Nota:  se  debe  eliminar  el  admin  reemplazado    
Params:  id:  number  createUserDto  Body:  {  nombre:  string,  email:  string,  password:  string  }   
userResponseDto  201:  {  id,  nombre,  correo,  rol,  empresa:  {  id,  nombre  }  } 
super_admin  
POST  /empresas/:id/usuarios  
Crea  un  nuevo  usuario  con  rol  ADMIN_EMPRESA  y  lo  asocia  a  una  empresa  que  no  tenga  administrador  asignado,  en  la  q  esta  ubicado  Nota:  se  valida  que  se  envio  un  usuario  con  rol  admin  
createUserDto  Body:  {  nombre:  string,  email:  string,  password:  string.  role:  ‚Äúadmin‚Äù  } 
userAdminResponseDto  201:  {  id,  nombre,  email,  rol:  'ADMIN_EMPRESA',  empresa:  {  id,  nombre  }  } 
super_admin  
DELETE  /empresas/:id  recibe  id  de  una  empresa  busca  si  existe  y  elimina  de  la  Bd  
Params:  id:  number   
204:  deleted  recurso  bieneliminado  
super_admin  
 
2.  Modulo  empresas  
 Metodo  Endpoint  descripcion  DTo  entrada  Dto  Salida  Rol  requerido  
GET  /empresas/:id   Nota:  toma  el  empresaId  del  token   payload  del  admin  ,  empresaid  relacionada  
Obtiene  los  detalles  de  su  empresa  (datos  generales,  tiene  administrador  asignado,  y  parqueaderos  asociados).   Nota:  aca  mismo  se  obtienes  los  operadores  y  admin  de  la  empresa   
-  200:  {  id,  nombre,  nit,  administrador?:  {  id,  nombre,  email  },  parqueaderos:[]} 
admin:  solo  puede  ver  detalles  su  empresa  relacionada  
PUT  /empresas   Nota:  toma  el  empresaId  del  token   payload  del  admin  ,  empresaid  relacionada  
Actualiza  los  datos  b√°sicos  de  la  empresa  (nombre,  nit,  direcci√≥n,  tel√©fono,  etc.).  
createEmpresaDto  Body:  {  nit:  string,  nombre:  string,  direccion?:  string  } 
EmpresaResponseDto  200:  {  id,  nombre,  nit,  administrador?:  {  id,  nombre,  email  },  parqueaderos:[]} 
admin:  modifica  propiedades  basicas  de  su  empresa  
POST  /empresas/usuarios  Nota:  toma  el  empresaId  del  token   payload  del  admin  ,  empresaid  relacionada  
Crea  un  nuevo  usuario  operador  asociado  la  empresa.  Solo  el  administrador  de  esa  empresa  puede  hacerlo.   Nota:  se  valida  se  envio  rol  de  operador  llama  servicio  user  ->  crear  usuario  
CreateUserDto  Body:  {  nombre,  correo,  contrase√±a,  id_rol  (solo  operador)  } 
userResponseDto  201:  {  id,  nombre,  correo,  rol,  empresa:  {  id,  nombre  }  } 
admin:  crea  operadores  para  su  empresa  

      
 